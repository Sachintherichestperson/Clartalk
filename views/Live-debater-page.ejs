<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Video</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        /* General Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #2a3d7d, #b21f1f, #fdbb2d);
            font-family: 'Poppins', sans-serif;
            color: white;
            line-height: 1.6;
            padding: 20px 0;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Video Section */
        .player {
            display: flex;
            justify-content: space-between;
            gap: 20px;
            margin-bottom: 30px;
        }

        .local-video, .remote-video {
            width: 48%;
            height: 450px;
            background-color: #1f1f2e;
            position: relative;
            border-radius: 15px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            padding: 10px;
        }

        .local-video:before, .remote-video:before {
            content: "Live";
            position: absolute;
            top: 15px;
            left: 20px;
            background: rgba(255, 0, 0, 0.853);
            padding: 8px 15px;
            border-radius: 5px;
            font-size: 14px;
            font-weight: 600;
            z-index: 10;
        }

        .local-video:hover, .remote-video:hover {
            transform: scale(1.05);
            box-shadow: 0 12px 25px rgba(0, 0, 0, 0.6);
        }

        /* About Video Section */
        .about-video {
            background-color: rgba(0, 0, 0, 0.8);
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.6);
            margin-top: 30px;
        }

        .single-comment {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            transition: transform 0.3s ease;
        }

        .single-comment strong {
            font-size: 18px;
            color: #ffcc00;
        }

        .single-comment p {
            margin: 0;
            font-size: 16px;
            color: #f0f0f0;
        }

        .single-comment:hover {
            transform: translateX(15px);
            background-color: rgba(255, 255, 255, 0.2);
        }

        /* End Call Button Section */
        .end-call-btn {
            padding: 12px 30px;
            font-size: 16px;
            border: none;
            border-radius: 25px;
            background: linear-gradient(135deg, #ff4b2b, #ff416c);
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            text-transform: uppercase;
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        .end-call-btn:hover {
            background: linear-gradient(135deg, #f38a1f, #f92f3f);
            transform: scale(1.05) translateX(-50%);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .player {
                flex-direction: column;
                align-items: center;
            }

            .local-video, .remote-video {
                width: 100%;
                height: auto;
            }

            .single-comment {
                flex-direction: column;
                align-items: flex-start;
            }

            .end-call-btn {
                width: 100%;
                padding: 15px 40px;
                font-size: 18px;
            }
            video{
                transform: scaleX(-1);
                object-fit: cover;
                height: 430px;
                width: 100%;
            }
        }
            video{
                transform: scaleX(-1);
                object-fit: cover;
                height: 430px;
                width: 628px;
            }
    </style>
</head>
<body>
    <section>
        <div class="container">
            <!-- Video Player Section -->
            <div class="player">
                <div class="local-video">
                    <video id="localVideo" autoplay muted playsinline></video>
                </div>
                <div class="remote-video">
                    <video id="remoteVideo" autoplay muted playsinline></video>
                    <!-- End Call Button inside the remote-video div -->
                    <button class="end-call-btn">End Call</button>
                </div>
            </div>

            <!-- About Video Section -->
            <div class="about-video">
                <!-- Title has been changed from "Followers" to "Live Comments" -->
                <div class="single-comment">
                    <strong>Shyam:</strong> 
                    <p>Daro Mat Mitr!</p>
                </div>
                <div class="single-comment">
                    <strong>Rohit:</strong> 
                    <p>Amazing Video!</p>
                </div>
            </div>
        </div>
    </section>
</body>
<script src="/socket.io/socket.io.js"></script>
<!-- <script>
    let peerConnection;
const configuration = {
    iceServers: [{ urls: "stun:stun.l.google.com:19302" }], // Use Google's public STUN server
};
const socket = io();

// Unique live session ID
const liveId = "<%= Live._id %>";
console.log("Live ID:", liveId);

socket.emit("sendLive", liveId);

socket.on("signal", async (data) => {
    if (data.sdp) {
        await peerConnection.setRemoteDescription(new RTCSessionDescription(data.sdp));
        if (data.sdp.type === "offer") {
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            socket.emit("signal", { liveId, data: { sdp: peerConnection.localDescription } });
        }
    } else if (data.candidate) {
        await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
    }
});

async function initLiveVideo() {
    try {
        // Access local media
        const localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });

        // Display the local video stream
        const localVideo = document.getElementById("localVideo");
        localVideo.srcObject = localStream;

        // Set up peer connection
        peerConnection = new RTCPeerConnection(configuration);

        // Add local stream tracks to peer connection
        localStream.getTracks().forEach((track) => peerConnection.addTrack(track, localStream));

        // Handle remote stream
        peerConnection.ontrack = (event) => {
            const remoteVideo = document.getElementById("remoteVideo");
            if (!remoteVideo.srcObject) {
                remoteVideo.srcObject = event.streams[0];
            }
        };

        // Send ICE candidates to the signaling server
        peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
                socket.emit("signal", { liveId, data: { candidate: event.candidate } });
            }
        };

        // Create offer
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
        socket.emit("signal", { liveId, data: { sdp: peerConnection.localDescription } });
    } catch (error) {
        console.error("Error initializing live video:", error);
    }
}

// Initialize live video on page load
document.addEventListener("DOMContentLoaded", initLiveVideo);

</script> -->
<!-- <script>
    let peerConnections = {}; // Keep track of peers
const configuration = {
    iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
};
const socket = io();
const liveId = "<%= Live._id %>";
console.log("Live ID:", liveId);

socket.emit("sendLive", liveId);

socket.on("user-joined", (peerId) => {
    console.log("User joined:", peerId);
    createOffer(peerId); // Create an offer for the new user
});

socket.on("user-left", (peerId) => {
    console.log("User left:", peerId);
    if (peerConnections[peerId]) {
        peerConnections[peerId].close();
        delete peerConnections[peerId];
    }
});

socket.on("signal", async ({ sender, data }) => {
    if (!peerConnections[sender]) {
        createPeerConnection(sender);
    }

    if (data.sdp) {
        await peerConnections[sender].setRemoteDescription(new RTCSessionDescription(data.sdp));
        if (data.sdp.type === "offer") {
            const answer = await peerConnections[sender].createAnswer();
            await peerConnections[sender].setLocalDescription(answer);
            socket.emit("signal", { data: { sdp: peerConnections[sender].localDescription } });
        }
    } else if (data.candidate) {
        await peerConnections[sender].addIceCandidate(new RTCIceCandidate(data.candidate));
    }
});

async function initLiveVideo() {
    try {
        const localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        const localVideo = document.getElementById("localVideo");
        localVideo.srcObject = localStream;

        // Share the local stream with each new peer
        socket.on("user-joined", (peerId) => {
            createPeerConnection(peerId, localStream);
            createOffer(peerId);
        });
    } catch (error) {
        console.error("Error initializing live video:", error);
    }
}

function createPeerConnection(peerId, localStream = null) {
    const peerConnection = new RTCPeerConnection(configuration);
    peerConnections[peerId] = peerConnection;

    if (localStream) {
        localStream.getTracks().forEach((track) => peerConnection.addTrack(track, localStream));
    }

    peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
            socket.emit("signal", { data: { candidate: event.candidate } });
        }
    };

    peerConnection.ontrack = (event) => {
        const remoteVideo = document.getElementById("remoteVideo");
        if (!remoteVideo.srcObject) {
            remoteVideo.srcObject = event.streams[0];
        }
    };

    return peerConnection;
}

async function createOffer(peerId) {
    const peerConnection = peerConnections[peerId];
    const offer = await peerConnection.createOffer();
    await peerConnection.setLocalDescription(offer);
    socket.emit("signal", { data: { sdp: peerConnection.localDescription } });
}

// Initialize the live video on page load
document.addEventListener("DOMContentLoaded", initLiveVideo);

</script> -->
<script>
    const socket = io(); // Connect to the signaling server
const configuration = {
    iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
};
let localStream = null;
let peerConnections = {};

// Get user media (camera and microphone)
async function initLocalStream() {
    try {
        localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        const localVideo = document.getElementById("remoteVideo");
        localVideo.srcObject = localStream;
        localVideo.play();
        console.log("Local stream initialized.");
    } catch (error) {
        console.error("Error accessing media devices:", error);
    }
}

// Create a new RTCPeerConnection for a peer
function createPeerConnection(peerId, localStream = null) {
    if (peerConnections[peerId]) {
        console.log(`Peer connection for ${peerId} already exists.`);
        return peerConnections[peerId];
    }

    console.log(`Creating peer connection for ${peerId}`);
    const peerConnection = new RTCPeerConnection(configuration);
    peerConnections[peerId] = peerConnection;

    if (localStream) {
        localStream.getTracks().forEach((track) => {
            peerConnection.addTrack(track, localStream);
        });
    }

    peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
            socket.emit("signal", { data: { candidate: event.candidate }, sender: socket.id, target: peerId });
        }
    };

    peerConnection.ontrack = (event) => {
        console.log("Received remote track for", peerId);
        const remoteVideo = document.getElementById("localVideo");
        if (!remoteVideo.srcObject) {
            remoteVideo.srcObject = event.streams[0];
        }
    };

    return peerConnection;
}

// Create an offer for a peer
async function createOffer(peerId) {
    console.log(`Creating offer for ${peerId}`);
    const peerConnection = peerConnections[peerId];
    if (!peerConnection) {
        console.error(`Peer connection for ${peerId} not found!`);
        return;
    }

    const offer = await peerConnection.createOffer();
    await peerConnection.setLocalDescription(offer);
    socket.emit("signal", { data: { sdp: peerConnection.localDescription }, sender: socket.id, target: peerId });
}

// Handle incoming signals (SDP and ICE candidates)
async function handleSignal({ data, sender }) {
    let peerConnection = peerConnections[sender];
    if (!peerConnection) {
        console.log(`Peer connection for ${sender} does not exist, creating it now.`);
        peerConnection = createPeerConnection(sender, localStream);
    }

    if (data.sdp) {
        console.log("Received SDP:", data.sdp.type);
        await peerConnection.setRemoteDescription(new RTCSessionDescription(data.sdp));
        if (data.sdp.type === "offer") {
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            socket.emit("signal", { data: { sdp: peerConnection.localDescription }, sender: socket.id, target: sender });
        }
    } else if (data.candidate) {
        console.log("Received ICE candidate.");
        await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
    }
}

// Handle user joining
socket.on("user-joined", (peerId) => {
    console.log("User joined:", peerId);

    if (!peerConnections[peerId]) {
        createPeerConnection(peerId, localStream);
    }

    createOffer(peerId);
});

// Handle signal
socket.on("signal", handleSignal);

// Handle user leaving
socket.on("user-left", (peerId) => {
    console.log("User left:", peerId);
    if (peerConnections[peerId]) {
        peerConnections[peerId].close();
        delete peerConnections[peerId];
    }
});

// Initialize
async function initialize() {
    await initLocalStream();

    socket.emit("join-room", { roomId: "your-room-id" }); // Replace with dynamic room ID
}

initialize();

</script>
</html>
